{"ast":null,"code":"import React, { useState, useEffect } from 'react';\nimport { useRecoilTransactionObserver_UNSTABLE, useRecoilSnapshot, useGotoRecoilSnapshot } from 'recoil';\nimport { formatFiberNodes } from './formatFiberNodes'; // grabs isPersistedState from sessionStorage\n\nlet isPersistedState = sessionStorage.getItem('isPersistedState'); // isRestored state disables snapshots from being recorded\n// when we jump backwards\n\nlet isRestoredState = false; // set default throttle to 70, throttle timer changes with every snapshot\n\nlet throttleTimer = 0;\nlet throttleLimit = 70; // persistedSnapshots initially null\n// let persistedSnapshots = null;\n\nexport default function RecoilizeDebugger(props) {\n  // We should ask for Array of atoms and selectors.\n  // Captures all atoms that were defined to get the initial state\n  // Define a recoilizeRoot variable which will be assigned based on whether a root is passed in as a prop\n  let recoilizeRoot; // Check if a root was passed to props.\n\n  if (props.root) {\n    const {\n      root\n    } = props;\n    recoilizeRoot = root;\n  } else {\n    recoilizeRoot = document.getElementById('root');\n  }\n\n  const snapshot = useRecoilSnapshot(); // getNodes_UNSTABLE will return an iterable that contains atom and selector objects.\n\n  const nodes = [...snapshot.getNodes_UNSTABLE()]; // Local state of all previous snapshots to use for time traveling when requested by dev tools.\n\n  const [snapshots, setSnapshots] = useState([snapshot]); // const [isRestoredState, setRestoredState] = useState(false);\n\n  const gotoSnapshot = useGotoRecoilSnapshot();\n  const filteredSnapshot = {};\n  /*\r\n  A nodeDeps object is constructed using getDeps_UNSTABLE. \r\n  This object will then be used to construct a nodeSubscriptions object. \r\n  After continuous testing, getSubscriptions_UNSTABLE was deemed too unreliable. \r\n  */\n\n  const nodeDeps = {};\n  const nodeSubscriptions = {};\n  nodes.forEach(node => {\n    const getDeps = [...snapshot.getDeps_UNSTABLE(node)];\n    nodeDeps[node.key] = getDeps.map(dep => dep.key);\n  });\n\n  for (let key in nodeDeps) {\n    nodeDeps[key].forEach(node => {\n      if (nodeSubscriptions[node]) {\n        nodeSubscriptions[node].push(key);\n      } else {\n        nodeSubscriptions[node] = [key];\n      }\n    });\n  } // Traverse all atoms and selector state nodes and get value\n\n\n  nodes.forEach((node, index) => {\n    const type = node.__proto__.constructor.name;\n    const contents = snapshot.getLoadable(node).contents; // Construct node data structure for dev tool to consume\n\n    filteredSnapshot[node.key] = {\n      type,\n      contents,\n      nodeDeps: nodeDeps[node.key],\n      nodeToNodeSubscriptions: nodeSubscriptions[node.key] ? nodeSubscriptions[node.key] : []\n    };\n  }); // React lifecycle hook on re-render\n\n  useEffect(() => {\n    // Window listener for messages from dev tool UI & background.js\n    window.addEventListener('message', onMessageReceived);\n\n    if (!isRestoredState) {\n      const devToolData = createDevToolDataObject(filteredSnapshot); // Post message to content script on every re-render of the developers application only if content script has started\n\n      sendWindowMessage('recordSnapshot', devToolData);\n    } else {\n      isRestoredState = false;\n    } // Clears the window event listener.\n\n\n    return () => window.removeEventListener('message', onMessageReceived);\n  }); // Listener callback for messages sent to windowf\n\n  const onMessageReceived = msg => {\n    // Add other actions from dev tool here\n    switch (msg.data.action) {\n      // Checks to see if content script has started before sending initial snapshot\n      case 'contentScriptStarted':\n        if (isPersistedState === 'false' || isPersistedState === null) {\n          const initialFilteredSnapshot = formatAtomSelectorRelationship(filteredSnapshot); //creating a indexDiff variable\n          //only created on initial creation of devToolData\n          //determines difference in length of backend snapshots array and frontend snapshotHistoryLength to avoid off by one error\n\n          const indexDiff = snapshots.length - 1;\n          const devToolData = createDevToolDataObject(initialFilteredSnapshot, indexDiff);\n          sendWindowMessage('moduleInitialized', devToolData);\n        } else {\n          setProperIndexForPersistedState();\n          sendWindowMessage('persistSnapshots', null);\n        }\n\n        break;\n      // Listens for a request from dev tool to time travel to previous state of the app.\n\n      case 'snapshotTimeTravel':\n        timeTravelToSnapshot(msg);\n        break;\n\n      case 'persistState':\n        switchPersistMode();\n        break;\n      // Implementing the throttle change\n\n      case 'throttleEdit':\n        throttleLimit = parseInt(msg.data.payload.value);\n        break;\n\n      default:\n        break;\n    }\n  }; // assigns or switches isPersistedState in sessionStorage\n\n\n  const switchPersistMode = () => {\n    if (isPersistedState === 'false' || isPersistedState === null) {\n      // switch isPersistedState in sessionStorage to true\n      sessionStorage.setItem('isPersistedState', true); // stores the length of current list of snapshots in sessionStorage\n\n      sessionStorage.setItem('persistedSnapshots', snapshots.length);\n    } else {\n      // switch isPersistedState in sessionStorage to false\n      sessionStorage.setItem('isPersistedState', false);\n    }\n  }; // function retreives length and fills snapshot array\n\n\n  const setProperIndexForPersistedState = () => {\n    const retreived = sessionStorage.getItem('persistedSnapshots');\n    const snapshotsArray = new Array(Number(retreived) + 1).fill({});\n    setSnapshots(snapshotsArray);\n  }; // Sends window an action and payload message.\n\n\n  const sendWindowMessage = (action, payload) => {\n    window.postMessage(JSON.parse(JSON.stringify({\n      action,\n      payload\n    })), '*');\n  };\n\n  const createDevToolDataObject = (filteredSnapshot, diff) => {\n    if (diff === undefined) {\n      return {\n        filteredSnapshot: filteredSnapshot,\n        componentAtomTree: formatFiberNodes(recoilizeRoot._reactRootContainer._internalRoot.current)\n      };\n    } else {\n      return {\n        filteredSnapshot: filteredSnapshot,\n        componentAtomTree: formatFiberNodes(recoilizeRoot._reactRootContainer._internalRoot.current),\n        indexDiff: diff\n      };\n    }\n  };\n\n  const formatAtomSelectorRelationship = filteredSnapshot => {\n    if (window.$recoilDebugStates && Array.isArray(window.$recoilDebugStates) && window.$recoilDebugStates.length) {\n      let snapObj = window.$recoilDebugStates[window.$recoilDebugStates.length - 1];\n\n      if (snapObj.hasOwnProperty('nodeDeps')) {\n        for (let [key, value] of snapObj.nodeDeps) {\n          filteredSnapshot[key].nodeDeps = Array.from(value);\n        }\n      }\n\n      if (snapObj.hasOwnProperty('nodeToNodeSubscriptions')) {\n        for (let [key, value] of snapObj.nodeToNodeSubscriptions) {\n          filteredSnapshot[key].nodeToNodeSubscriptions = Array.from(value);\n        }\n      }\n    }\n\n    return filteredSnapshot;\n  }; // Will add hover effect over highlighted component\n  // Takes an argument of msg.data which contains name and payload\n\n\n  const activateHover = payload => {\n    let name = payload.name;\n  }; // FOR TIME TRAVEL: time travels to a given snapshot, re renders application.\n\n\n  const timeTravelToSnapshot = async msg => {\n    // await setRestoredState(true);\n    // await gotoSnapshot(snapshots[msg.data.payload.snapshotIndex]);\n    // await setRestoredState(false);\n    isRestoredState = true;\n    await gotoSnapshot(snapshots[msg.data.payload.snapshotIndex]);\n  }; // FOR TIME TRAVEL: Recoil hook to fire a callback on every atom/selector change -- research Throttle\n\n\n  useRecoilTransactionObserver_UNSTABLE(({\n    snapshot\n  }) => {\n    const now = new Date().getTime();\n\n    if (now - throttleTimer < throttleLimit) {\n      isRestoredState = true;\n    } else {\n      throttleTimer = now;\n    }\n\n    if (!isRestoredState) {\n      setSnapshots([...snapshots, snapshot]);\n    }\n  });\n  return null;\n}","map":{"version":3,"sources":["/Users/imin-ug/Documents/GitHub/dstore_admin/node_modules/recoilize/index.js"],"names":["React","useState","useEffect","useRecoilTransactionObserver_UNSTABLE","useRecoilSnapshot","useGotoRecoilSnapshot","formatFiberNodes","isPersistedState","sessionStorage","getItem","isRestoredState","throttleTimer","throttleLimit","RecoilizeDebugger","props","recoilizeRoot","root","document","getElementById","snapshot","nodes","getNodes_UNSTABLE","snapshots","setSnapshots","gotoSnapshot","filteredSnapshot","nodeDeps","nodeSubscriptions","forEach","node","getDeps","getDeps_UNSTABLE","key","map","dep","push","index","type","__proto__","constructor","name","contents","getLoadable","nodeToNodeSubscriptions","window","addEventListener","onMessageReceived","devToolData","createDevToolDataObject","sendWindowMessage","removeEventListener","msg","data","action","initialFilteredSnapshot","formatAtomSelectorRelationship","indexDiff","length","setProperIndexForPersistedState","timeTravelToSnapshot","switchPersistMode","parseInt","payload","value","setItem","retreived","snapshotsArray","Array","Number","fill","postMessage","JSON","parse","stringify","diff","undefined","componentAtomTree","_reactRootContainer","_internalRoot","current","$recoilDebugStates","isArray","snapObj","hasOwnProperty","from","activateHover","snapshotIndex","now","Date","getTime"],"mappings":"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","sourcesContent":["import React, {useState, useEffect} from 'react';\r\nimport {\r\n  useRecoilTransactionObserver_UNSTABLE,\r\n  useRecoilSnapshot,\r\n  useGotoRecoilSnapshot,\r\n} from 'recoil';\r\nimport {formatFiberNodes} from './formatFiberNodes';\r\n\r\n// grabs isPersistedState from sessionStorage\r\nlet isPersistedState = sessionStorage.getItem('isPersistedState');\r\n\r\n// isRestored state disables snapshots from being recorded\r\n// when we jump backwards\r\nlet isRestoredState = false;\r\n\r\n// set default throttle to 70, throttle timer changes with every snapshot\r\nlet throttleTimer = 0;\r\nlet throttleLimit = 70;\r\n\r\n// persistedSnapshots initially null\r\n// let persistedSnapshots = null;\r\n\r\nexport default function RecoilizeDebugger(props) {\r\n  // We should ask for Array of atoms and selectors.\r\n  // Captures all atoms that were defined to get the initial state\r\n\r\n  // Define a recoilizeRoot variable which will be assigned based on whether a root is passed in as a prop\r\n  let recoilizeRoot;\r\n\r\n  // Check if a root was passed to props.\r\n  if (props.root) {\r\n    const {root} = props;\r\n    recoilizeRoot = root;\r\n  } else {\r\n    recoilizeRoot = document.getElementById('root');\r\n  }\r\n\r\n  const snapshot = useRecoilSnapshot();\r\n\r\n  // getNodes_UNSTABLE will return an iterable that contains atom and selector objects.\r\n  const nodes = [...snapshot.getNodes_UNSTABLE()];\r\n  // Local state of all previous snapshots to use for time traveling when requested by dev tools.\r\n  const [snapshots, setSnapshots] = useState([snapshot]);\r\n  // const [isRestoredState, setRestoredState] = useState(false);\r\n  const gotoSnapshot = useGotoRecoilSnapshot();\r\n\r\n  const filteredSnapshot = {};\r\n\r\n  /*\r\n  A nodeDeps object is constructed using getDeps_UNSTABLE. \r\n  This object will then be used to construct a nodeSubscriptions object. \r\n  After continuous testing, getSubscriptions_UNSTABLE was deemed too unreliable. \r\n  */\r\n\r\n  const nodeDeps = {};\r\n  const nodeSubscriptions = {};\r\n\r\n  nodes.forEach(node => {\r\n    const getDeps = [...snapshot.getDeps_UNSTABLE(node)];\r\n    nodeDeps[node.key] = getDeps.map(dep => dep.key);\r\n  });\r\n\r\n  for (let key in nodeDeps) {\r\n    nodeDeps[key].forEach(node => {\r\n      if (nodeSubscriptions[node]) {\r\n        nodeSubscriptions[node].push(key);\r\n      } else {\r\n        nodeSubscriptions[node] = [key];\r\n      }\r\n    });\r\n  }\r\n\r\n  // Traverse all atoms and selector state nodes and get value\r\n  nodes.forEach((node, index) => {\r\n    const type = node.__proto__.constructor.name;\r\n    const contents = snapshot.getLoadable(node).contents;\r\n    // Construct node data structure for dev tool to consume\r\n    filteredSnapshot[node.key] = {\r\n      type,\r\n      contents,\r\n      nodeDeps: nodeDeps[node.key],\r\n      nodeToNodeSubscriptions: nodeSubscriptions[node.key]\r\n        ? nodeSubscriptions[node.key]\r\n        : [],\r\n    };\r\n  });\r\n\r\n  // React lifecycle hook on re-render\r\n  useEffect(() => {\r\n    // Window listener for messages from dev tool UI & background.js\r\n    window.addEventListener('message', onMessageReceived);\r\n\r\n    if (!isRestoredState) {\r\n      const devToolData = createDevToolDataObject(filteredSnapshot);\r\n      // Post message to content script on every re-render of the developers application only if content script has started\r\n      sendWindowMessage('recordSnapshot', devToolData);\r\n    } else {\r\n      isRestoredState = false;\r\n    }\r\n\r\n    // Clears the window event listener.\r\n    return () => window.removeEventListener('message', onMessageReceived);\r\n  });\r\n\r\n  // Listener callback for messages sent to windowf\r\n  const onMessageReceived = msg => {\r\n    // Add other actions from dev tool here\r\n    switch (msg.data.action) {\r\n      // Checks to see if content script has started before sending initial snapshot\r\n      case 'contentScriptStarted':\r\n        if (isPersistedState === 'false' || isPersistedState === null) {\r\n          const initialFilteredSnapshot = formatAtomSelectorRelationship(\r\n            filteredSnapshot,\r\n          );\r\n\r\n          //creating a indexDiff variable\r\n          //only created on initial creation of devToolData\r\n          //determines difference in length of backend snapshots array and frontend snapshotHistoryLength to avoid off by one error\r\n          const indexDiff = snapshots.length - 1;\r\n\r\n          const devToolData = createDevToolDataObject(\r\n            initialFilteredSnapshot,\r\n            indexDiff,\r\n          );\r\n          sendWindowMessage('moduleInitialized', devToolData);\r\n        } else {\r\n          setProperIndexForPersistedState();\r\n          sendWindowMessage('persistSnapshots', null);\r\n        }\r\n        break;\r\n      // Listens for a request from dev tool to time travel to previous state of the app.\r\n      case 'snapshotTimeTravel':\r\n        timeTravelToSnapshot(msg);\r\n        break;\r\n      case 'persistState':\r\n        switchPersistMode();\r\n        break;\r\n      // Implementing the throttle change\r\n      case 'throttleEdit':\r\n        throttleLimit = parseInt(msg.data.payload.value);\r\n        break;\r\n      default:\r\n        break;\r\n    }\r\n  };\r\n\r\n  // assigns or switches isPersistedState in sessionStorage\r\n  const switchPersistMode = () => {\r\n    if (isPersistedState === 'false' || isPersistedState === null) {\r\n      // switch isPersistedState in sessionStorage to true\r\n      sessionStorage.setItem('isPersistedState', true);\r\n\r\n      // stores the length of current list of snapshots in sessionStorage\r\n      sessionStorage.setItem('persistedSnapshots', snapshots.length);\r\n    } else {\r\n      // switch isPersistedState in sessionStorage to false\r\n      sessionStorage.setItem('isPersistedState', false);\r\n    }\r\n  };\r\n\r\n  // function retreives length and fills snapshot array\r\n  const setProperIndexForPersistedState = () => {\r\n    const retreived = sessionStorage.getItem('persistedSnapshots');\r\n    const snapshotsArray = new Array(Number(retreived) + 1).fill({});\r\n    setSnapshots(snapshotsArray);\r\n  };\r\n\r\n  // Sends window an action and payload message.\r\n  const sendWindowMessage = (action, payload) => {\r\n    window.postMessage(\r\n      JSON.parse(JSON.stringify({\r\n        action,\r\n        payload,\r\n      })),\r\n      '*',\r\n    );\r\n  };\r\n\r\n  const createDevToolDataObject = (filteredSnapshot, diff) => {\r\n    if (diff === undefined) {\r\n      return {\r\n        filteredSnapshot: filteredSnapshot,\r\n        componentAtomTree: formatFiberNodes(\r\n          recoilizeRoot._reactRootContainer._internalRoot.current,\r\n        ),\r\n      };\r\n    } else {\r\n      return {\r\n        filteredSnapshot: filteredSnapshot,\r\n        componentAtomTree: formatFiberNodes(\r\n          recoilizeRoot._reactRootContainer._internalRoot.current,\r\n        ),\r\n        indexDiff: diff,\r\n      };\r\n    }\r\n  };\r\n\r\n  const formatAtomSelectorRelationship = filteredSnapshot => {\r\n    if (\r\n      window.$recoilDebugStates &&\r\n      Array.isArray(window.$recoilDebugStates) &&\r\n      window.$recoilDebugStates.length\r\n    ) {\r\n      let snapObj =\r\n        window.$recoilDebugStates[window.$recoilDebugStates.length - 1];\r\n      if (snapObj.hasOwnProperty('nodeDeps')) {\r\n        for (let [key, value] of snapObj.nodeDeps) {\r\n          filteredSnapshot[key].nodeDeps = Array.from(value);\r\n        }\r\n      }\r\n      if (snapObj.hasOwnProperty('nodeToNodeSubscriptions')) {\r\n        for (let [key, value] of snapObj.nodeToNodeSubscriptions) {\r\n          filteredSnapshot[key].nodeToNodeSubscriptions = Array.from(value);\r\n        }\r\n      }\r\n    }\r\n    return filteredSnapshot;\r\n  };\r\n\r\n  // Will add hover effect over highlighted component\r\n  // Takes an argument of msg.data which contains name and payload\r\n  const activateHover = payload => {\r\n    let name = payload.name;\r\n  };\r\n\r\n  // FOR TIME TRAVEL: time travels to a given snapshot, re renders application.\r\n  const timeTravelToSnapshot = async msg => {\r\n    // await setRestoredState(true);\r\n    // await gotoSnapshot(snapshots[msg.data.payload.snapshotIndex]);\r\n    // await setRestoredState(false);\r\n    isRestoredState = true;\r\n    await gotoSnapshot(snapshots[msg.data.payload.snapshotIndex]);\r\n  };\r\n\r\n  // FOR TIME TRAVEL: Recoil hook to fire a callback on every atom/selector change -- research Throttle\r\n  useRecoilTransactionObserver_UNSTABLE(({snapshot}) => {\r\n    const now = new Date().getTime();\r\n    if (now - throttleTimer < throttleLimit) {\r\n      isRestoredState = true;\r\n    } else {\r\n      throttleTimer = now;\r\n    }\r\n\r\n    if (!isRestoredState) {\r\n      setSnapshots([...snapshots, snapshot]);\r\n    }\r\n  });\r\n\r\n  return null;\r\n}\r\n"]},"metadata":{},"sourceType":"module"}
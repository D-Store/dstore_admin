{"ast":null,"code":"// node parameter should be root of the fiber node tree, can be grapped with startNode from below\n// const startNode = document.getElementById('root')._reactRootContainer._internalRoot.current;\nconst formatFiberNodes = node => {\n  const formattedNode = {\n    // this function grabs a 'name' based on the tag of the node\n    name: assignName(node),\n    tag: node.tag,\n    children: [],\n    recoilNodes: createAtomsSelectorArray(node),\n    actualDuration: node.actualDuration,\n    treeBaseDuration: node.treeBaseDuration,\n    wasSuspended: node.return && node.return.tag === 13 ? true : false\n  }; // loop through and recursively call all nodes to format their 'sibling' and 'child' properties to our desired tree shape\n\n  let currentNode = node.child;\n\n  while (currentNode) {\n    formattedNode.children.push(formatFiberNodes(currentNode));\n    currentNode = currentNode.sibling;\n  }\n\n  return formattedNode;\n};\n\nconst createAtomsSelectorArray = node => {\n  // initialize empty array for all atoms and selectors.  Elements will be all atom and selector names, as strings\n  const recoilNodes = []; //start the pointer at node.memoizedState. All nodes should have this key.\n\n  let currentNode = node.memoizedState; // Traverse through the memoizedStates and look for the deps key which holds selectors or state.\n\n  while (currentNode) {\n    // if the memoizedState has a deps key, and that deps key is an array\n    // then the first value of that array will be an atom or selector\n    if (typeof currentNode === 'object' && currentNode.hasOwnProperty('memoizedState') && typeof currentNode.memoizedState === 'object' && currentNode.memoizedState !== null && !Array.isArray(currentNode.memoizedState) && currentNode.memoizedState.hasOwnProperty('deps')) {\n      if (Array.isArray(currentNode.memoizedState.deps) && typeof currentNode.memoizedState.deps[0] === 'object' && currentNode.memoizedState.deps[0] !== null) {\n        // if recoilNodes (arr) includes the current atom or selector\n        if (!recoilNodes.includes(currentNode.memoizedState.deps[0].key)) {\n          // otherwise push atom/selector to recoilNodes\n          recoilNodes.push(currentNode.memoizedState.deps[0].key);\n        }\n      }\n    } // move onto next node\n\n\n    currentNode = currentNode.next;\n  } // return atom and selectors array\n\n\n  return recoilNodes;\n}; // keep an eye on this section as we test bigger and bigger applications SEAN\n\n\nconst assignName = node => {\n  // Returns symbol key if $$typeof is defined. Some components, such as context providers, will have this value.\n  if (node.type && node.type.$$typeof) return Symbol.keyFor(node.type.$$typeof); // Return suspense if tag is equal to 13, which is associated with Suspense components.\n\n  if (node.tag === 13) return 'Suspense'; // Find name of a class component\n\n  if (node.type && node.type.name) return node.type.name; // Tag 5 === HostComponent\n\n  if (node.tag === 5) return `${node.type}`; // Tag 3 === HostRoot\n\n  if (node.tag === 3) return 'HR'; // Tag 6 === HostText\n\n  if (node.tag === 6) return node.memoizedProps; // Tag 7 === Fragment\n\n  if (node.tag === 7) return 'Fragment';\n};\n\nmodule.exports = {\n  formatFiberNodes\n}; // if testing this function on the browser, use line below to log the formatted tree in the console\n//let formattedFiberNodes = formatFiberNodes(document.getElementById('root')._reactRootContainer._internalRoot.current)","map":{"version":3,"sources":["/Users/imin-ug/Documents/GitHub/dstore_admin/node_modules/recoilize/formatFiberNodes.js"],"names":["formatFiberNodes","node","formattedNode","name","assignName","tag","children","recoilNodes","createAtomsSelectorArray","actualDuration","treeBaseDuration","wasSuspended","return","currentNode","child","push","sibling","memoizedState","hasOwnProperty","Array","isArray","deps","includes","key","next","type","$$typeof","Symbol","keyFor","memoizedProps","module","exports"],"mappings":"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","sourcesContent":["// node parameter should be root of the fiber node tree, can be grapped with startNode from below\r\n// const startNode = document.getElementById('root')._reactRootContainer._internalRoot.current;\r\n\r\nconst formatFiberNodes = node => {\r\n  const formattedNode = {\r\n    // this function grabs a 'name' based on the tag of the node\r\n    name: assignName(node),\r\n    tag: node.tag,\r\n    children: [],\r\n    recoilNodes: createAtomsSelectorArray(node),\r\n    actualDuration: node.actualDuration,\r\n    treeBaseDuration: node.treeBaseDuration,\r\n    wasSuspended: node.return && node.return.tag === 13 ? true : false,\r\n  };\r\n\r\n  // loop through and recursively call all nodes to format their 'sibling' and 'child' properties to our desired tree shape\r\n  let currentNode = node.child;\r\n  while (currentNode) {\r\n    formattedNode.children.push(formatFiberNodes(currentNode));\r\n    currentNode = currentNode.sibling;\r\n  }\r\n\r\n  return formattedNode;\r\n};\r\n\r\nconst createAtomsSelectorArray = node => {\r\n  // initialize empty array for all atoms and selectors.  Elements will be all atom and selector names, as strings\r\n  const recoilNodes = [];\r\n\r\n  //start the pointer at node.memoizedState. All nodes should have this key.\r\n  let currentNode = node.memoizedState;\r\n\r\n  // Traverse through the memoizedStates and look for the deps key which holds selectors or state.\r\n  while (currentNode) {\r\n    // if the memoizedState has a deps key, and that deps key is an array\r\n    // then the first value of that array will be an atom or selector\r\n    if (\r\n      typeof(currentNode) === 'object' &&\r\n      currentNode.hasOwnProperty('memoizedState') &&\r\n      typeof currentNode.memoizedState === 'object' &&\r\n      currentNode.memoizedState !== null &&\r\n      !Array.isArray(currentNode.memoizedState) &&\r\n      currentNode.memoizedState.hasOwnProperty('deps')\r\n    ) {\r\n      if (\r\n        Array.isArray(currentNode.memoizedState.deps) &&\r\n        typeof currentNode.memoizedState.deps[0] === 'object' &&\r\n        currentNode.memoizedState.deps[0] !== null\r\n      ) {\r\n        // if recoilNodes (arr) includes the current atom or selector\r\n        if (!recoilNodes.includes(currentNode.memoizedState.deps[0].key)) {\r\n          // otherwise push atom/selector to recoilNodes\r\n          recoilNodes.push(currentNode.memoizedState.deps[0].key);\r\n        }\r\n      }\r\n    }\r\n    // move onto next node\r\n    currentNode = currentNode.next;\r\n  }\r\n  // return atom and selectors array\r\n  return recoilNodes;\r\n};\r\n\r\n// keep an eye on this section as we test bigger and bigger applications SEAN\r\nconst assignName = node => {\r\n  // Returns symbol key if $$typeof is defined. Some components, such as context providers, will have this value.\r\n  if (node.type && node.type.$$typeof) return Symbol.keyFor(node.type.$$typeof);\r\n  // Return suspense if tag is equal to 13, which is associated with Suspense components.\r\n  if (node.tag === 13) return 'Suspense';\r\n  // Find name of a class component\r\n  if (node.type && node.type.name) return node.type.name;\r\n  // Tag 5 === HostComponent\r\n  if (node.tag === 5) return `${node.type}`;\r\n  // Tag 3 === HostRoot\r\n  if (node.tag === 3) return 'HR';\r\n  // Tag 6 === HostText\r\n  if (node.tag === 6) return node.memoizedProps;\r\n  // Tag 7 === Fragment\r\n  if (node.tag === 7) return 'Fragment';\r\n};\r\n\r\nmodule.exports = { formatFiberNodes };\r\n\r\n// if testing this function on the browser, use line below to log the formatted tree in the console\r\n//let formattedFiberNodes = formatFiberNodes(document.getElementById('root')._reactRootContainer._internalRoot.current)\r\n"]},"metadata":{},"sourceType":"script"}